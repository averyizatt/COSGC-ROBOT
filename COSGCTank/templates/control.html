<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>COSGC Rover Control</title>
<style>
:root {
    --bg: #0b0f17;
    --panel: rgba(255,255,255,0.06);
    --panel2: rgba(255,255,255,0.09);
    --text: #e9eefc;
    --muted: rgba(233,238,252,0.75);
    --border: rgba(233,238,252,0.14);
    --shadow: 0 10px 28px rgba(0,0,0,0.45);
    --green: #1fda7a;
    --yellow: #f5c84c;
    --red: #ff4d4f;
    --blue: #4da3ff;
}

* { box-sizing: border-box; }
html, body { height: 100%; }
body {
    margin: 0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial;
    background: radial-gradient(1200px 700px at 20% 0%, rgba(77,163,255,0.18), transparent 60%),
                radial-gradient(900px 600px at 90% 15%, rgba(31,218,122,0.12), transparent 55%),
                var(--bg);
    color: var(--text);
}

.container { max-width: 1120px; margin: 0 auto; padding: 18px 16px 28px; }
.header { display: flex; align-items: center; justify-content: space-between; gap: 12px; flex-wrap: wrap; margin-bottom: 14px; }
.title { display: flex; align-items: baseline; gap: 10px; }
.title h1 { margin: 0; font-size: 22px; letter-spacing: 0.2px; }
.badge { font-size: 12px; padding: 4px 8px; border: 1px solid var(--border); border-radius: 999px; background: rgba(255,255,255,0.04); color: var(--muted); }
.meta { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
.pill { display: inline-flex; align-items: center; gap: 8px; padding: 7px 10px; border-radius: 999px; border: 1px solid var(--border); background: rgba(0,0,0,0.12); font-size: 13px; }
.dot { width: 9px; height: 9px; border-radius: 999px; background: var(--yellow); box-shadow: 0 0 0 3px rgba(245,200,76,0.16); }
.dot.ok { background: var(--green); box-shadow: 0 0 0 3px rgba(31,218,122,0.16); }
.dot.bad { background: var(--red); box-shadow: 0 0 0 3px rgba(255,77,79,0.16); }
.pill strong { font-weight: 650; }
.pill span { color: var(--muted); }

.row { display: grid; grid-template-columns: 1.55fr 1fr; gap: 14px; }
@media (max-width: 920px) { .row { grid-template-columns: 1fr; } }

.card { background: var(--panel); border: 1px solid var(--border); border-radius: 14px; box-shadow: var(--shadow); overflow: hidden; }
.card-h { padding: 12px 14px; border-bottom: 1px solid var(--border); background: rgba(255,255,255,0.03); display: flex; align-items: center; justify-content: space-between; gap: 10px; }
.card-b { padding: 14px; }

.video { width: 100%; aspect-ratio: 16 / 9; background: rgba(0,0,0,0.35); border: 1px solid var(--border); border-radius: 12px; }

select { padding: 8px 10px; border-radius: 10px; border: 1px solid var(--border); background: rgba(0,0,0,0.18); color: var(--text); }

.controls { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-top: 12px; }

.btn { user-select: none; border-radius: 12px; border: 1px solid var(--border); background: rgba(255,255,255,0.06); color: var(--text); padding: 12px 10px; cursor: pointer; transition: transform 0.04s ease, background 0.15s ease, border-color 0.15s ease; }
.btn:hover { background: rgba(255,255,255,0.09); border-color: rgba(233,238,252,0.22); }
.btn:active { transform: translateY(1px); }
.btn[disabled] { opacity: 0.45; cursor: not-allowed; }
.btn.primary { border-color: rgba(77,163,255,0.35); background: rgba(77,163,255,0.12); }
.btn.primary:hover { background: rgba(77,163,255,0.16); }
.btn.stop { border-color: rgba(255,77,79,0.45); background: rgba(255,77,79,0.12); font-weight: 750; }
.btn.stop:hover { background: rgba(255,77,79,0.16); }
.btn.active { border-color: rgba(31,218,122,0.55); background: rgba(31,218,122,0.16); }

.grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
@media (max-width: 520px) { .grid-2 { grid-template-columns: 1fr; } }

.hint { margin-top: 10px; color: var(--muted); font-size: 13px; line-height: 1.35; }
.field { background: rgba(255,255,255,0.04); border: 1px solid var(--border); border-radius: 12px; padding: 10px; }
.field label { display: flex; align-items: center; justify-content: space-between; gap: 10px; }
.field label span { color: var(--muted); font-size: 13px; }
.field input[type="number"] { width: 120px; padding: 8px 10px; border-radius: 10px; border: 1px solid var(--border); background: rgba(0,0,0,0.18); color: var(--text); }
.field input[type="range"] { width: 100%; }
.val { font-variant-numeric: tabular-nums; color: var(--muted); }
</style>
</head>
<body>

<div class="container">
    <div class="header">
        <div class="title">
            <h1>COSGC Rover Control</h1>
            <span class="badge">Hold-to-drive • RC/Autonomy • Live tuning</span>
        </div>
        <div class="meta">
            <span class="pill"><span class="dot" id="conn-dot"></span><strong id="conn">Connecting…</strong></span>
            <span class="pill"><span class="dot" id="estop-dot" style="background: rgba(233,238,252,0.25);"></span><strong id="e-stop">E‑STOP: OFF</strong></span>
            <span class="pill"><strong>Active</strong><span id="active-list">none</span></span>
            <span class="pill"><span class="dot" id="gp-dot" style="background: rgba(233,238,252,0.25);"></span><strong>Gamepad</strong><span id="gp-status">Not connected</span></span>
        </div>
    </div>

    <div class="row">
        <div class="card">
            <div class="card-h">
                <div>
                    <strong>Live video</strong>
                    <span class="badge" style="margin-left:8px;">update video URL in HTML</span>
                </div>
                <label style="display:flex;align-items:center;gap:8px;">
                    <span style="color:var(--muted);font-size:13px;">Mode</span>
                    <select id="mode-select">
                        <option value="rc">RC (manual)</option>
                        <option value="autonomous">Autonomous (generic)</option>
                        <option value="single_cam">Autonomous (single cam)</option>
                        <option value="stereo_cam">Autonomous (stereo)</option>
                    </select>
                </label>
            </div>
            <div class="card-b">
                <video class="video" id="video" src="http://YOUR_PI_IP:8554" autoplay playsinline></video>

                <div class="controls" aria-label="drive controls">
                    <button class="btn primary" id="btn-forward">Forward <span class="val">(W)</span></button>
                    <button class="btn" id="btn-stop">STOP</button>
                    <button class="btn" id="btn-left">Left <span class="val">(A)</span></button>
                    <button class="btn stop" id="btn-estop">E‑STOP</button>
                    <button class="btn" id="btn-right">Right <span class="val">(D)</span></button>
                    <button class="btn" id="btn-back">Back <span class="val">(S)</span></button>
                </div>

                <div class="hint">
                    <strong>Controls:</strong> hold <span class="val">W/A/S/D</span> or press/hold buttons. Releasing stops.
                    Space triggers E‑STOP. Xbox controller supported.
                </div>
            </div>
        </div>

        <div class="card">
            <div class="card-h">
                <strong>Settings & tuning</strong>
                <span class="badge">applies via <code>/settings</code></span>
            </div>
            <div class="card-b">
                <div class="field">
                    <label>
                        <span>Enable path smoothing</span>
                        <input id="smoothing-toggle" type="checkbox" />
                    </label>
                </div>

                <div style="height:10px;"></div>

                <div class="field"><label><span>Detector gamma</span><input id="t-gamma" type="number" step="0.05" min="0.5" max="1.5" value="0.9" /></label></div>
                <div style="height:10px;"></div>
                <div class="field"><label><span>Contour min area</span><input id="t-area" type="number" step="50" min="50" max="5000" value="400" /></label></div>
                <div style="height:10px;"></div>
                <div class="field"><label><span>Obstacle stop ymin</span><input id="t-ymin" type="number" step="0.02" min="0" max="1" value="0.35" /></label></div>
                <div style="height:10px;"></div>
                <div class="field"><label><span>Rock score threshold</span><input id="t-rockthr" type="number" step="0.05" min="0" max="1" value="0.45" /></label></div>
                <div style="height:10px;"></div>
                <div class="field">
                    <label>
                        <span>RC speed</span>
                        <span class="val" id="t-rcspeed-val">0.6</span>
                    </label>
                    <input id="t-rcspeed" type="range" min="0.2" max="1.0" step="0.05" value="0.6" />
                </div>

                <div style="height:10px;"></div>

                <div class="grid-2">
                    <button class="btn" id="t-apply">Apply settings</button>
                    <button class="btn stop" id="btn-clear-estop">Clear E‑STOP</button>
                </div>

                <div class="hint">
                    <strong>Tip:</strong> In non‑RC modes, manual controls are disabled.
                </div>
            </div>
        </div>
    </div>
</div>

<script>
// Map keys/actions
const keyAction = {
    'w': 'f',
    's': 'b',
    'a': 'l',
    'd': 'r',
    ' ': 's'
};

// Track pressed keys to avoid repeat start events
const pressed = new Set();
const keepaliveIntervals = {};
const failureCounts = {};
let disconnected = false;
let currentMode = 'rc';

function setConnState(ok) {
    const el = document.getElementById('conn');
    const dot = document.getElementById('conn-dot');
    if (ok) {
        el.textContent = 'Connected';
        if (dot) { dot.classList.add('ok'); dot.classList.remove('bad'); }
    } else {
        el.textContent = 'Disconnected';
        if (dot) { dot.classList.add('bad'); dot.classList.remove('ok'); }
    }
}

function setEStop(on) {
    const el = document.getElementById('e-stop');
    const dot = document.getElementById('estop-dot');
    el.textContent = (on ? 'E‑STOP: ON' : 'E‑STOP: OFF');
    if (dot) {
        if (on) dot.classList.add('bad');
        else dot.classList.remove('bad');
    }
}

function setActiveList(list) {
    const el = document.getElementById('active-list');
    if (!list || list.length === 0) el.textContent = 'none';
    else el.textContent = list.map(a => ({'f':'F','b':'B','l':'L','r':'R'}[a]||a)).join(', ');
}

function setModeUI(mode) {
    currentMode = mode;
    const sel = document.getElementById('mode-select');
    if (sel && sel.value !== mode) sel.value = mode;
    const disable = (mode !== 'rc');
    // disable buttons
    ['btn-forward','btn-back','btn-left','btn-right'].forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        el.disabled = disable;
        el.style.opacity = disable ? '0.5' : '1.0';
    });
}

async function postKeepalive(action, state) {
    try {
        const res = await fetch('/keepalive', {
            method: 'POST', headers: {'Content-Type':'application/json'},
            body: JSON.stringify({action: action, state: state})
        });
        if (!res.ok) throw new Error('bad');
        setConnState(true);
        failureCounts[action] = 0;
        return true;
    } catch (e) {
        failureCounts[action] = (failureCounts[action] || 0) + 1;
        if (failureCounts[action] >= 3) {
            disconnected = true;
            setConnState(false);
            // clear this action's interval to avoid spamming
            stopKeepalive(action, true);
        }
        return false;
    }
}

function sendState(action, state) {
    // backwards-compatible fallback for single-shot
    fetch(`/cmd/${action}/${state}`).catch(()=>{});
}

function startKeepalive(action) {
    if (disconnected) return;
    if (keepaliveIntervals[action]) return; // already running
    // immediate attempt
    postKeepalive(action, 'start');
    const id = setInterval(()=>postKeepalive(action,'start'), 200);
    keepaliveIntervals[action] = id;
    // visual
    setButtonActive(action, true);
}

function stopKeepalive(action, suppressFetch=false) {
    const id = keepaliveIntervals[action];
    if (id) { clearInterval(id); delete keepaliveIntervals[action]; }
    if (!suppressFetch) postKeepalive(action, 'stop');
    setButtonActive(action, false);
}

document.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    const a = keyAction[k];
    if (!a) return;
    // ignore manual controls if not in RC mode
    if (currentMode !== 'rc') return;
    if (pressed.has(k)) return; // already pressed
    pressed.add(k);
    if (a === 's') {
        // space toggles emergency stop (instant)
        fetch('/emergency_stop', {method:'POST'}).catch(()=>{});
    } else {
        startKeepalive(a);
    }
});

document.addEventListener('keyup', (e) => {
    const k = e.key.toLowerCase();
    const a = keyAction[k];
    if (!a) return;
    if (currentMode !== 'rc') return;
    pressed.delete(k);
    if (a === 's') return;
    stopKeepalive(a);
});

// Button/touch handlers for mobile
function wireButton(id, action) {
    const btn = document.getElementById(id);
    btn.addEventListener('touchstart', (ev) => { ev.preventDefault(); startKeepalive(action); });
    btn.addEventListener('mousedown', (ev) => { ev.preventDefault(); startKeepalive(action); });
    btn.addEventListener('touchend', (ev) => { ev.preventDefault(); stopKeepalive(action); });
    btn.addEventListener('mouseup', (ev) => { ev.preventDefault(); stopKeepalive(action); });
    // also handle mouseleave to stop when pointer leaves
    btn.addEventListener('mouseleave', (ev) => { stopKeepalive(action); });
}

wireButton('btn-forward','f');
wireButton('btn-left','l');
wireButton('btn-right','r');
wireButton('btn-back','b');

// mode selector
document.getElementById('mode-select').addEventListener('change', (ev)=>{
    const m = ev.target.value;
    fetch('/mode', {method:'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({mode: m})})
        .then(r=>r.json()).then(js=>{ setModeUI(js.mode); }).catch(()=>{ alert('Failed to set mode'); });
});

// STOP = soft stop (non e-stop)
document.getElementById('btn-stop').addEventListener('click', ()=>{ fetch('/cmd/s').catch(()=>{}); });
// E-stop buttons
document.getElementById('btn-estop').addEventListener('click', ()=>{ fetch('/emergency_stop',{method:'POST'}).catch(()=>{}); });
document.getElementById('btn-clear-estop').addEventListener('click', ()=>{ fetch('/clear_emergency',{method:'POST'}).catch(()=>{}); });

function setButtonActive(action, on) {
    const map = {'f':'btn-forward','b':'btn-back','l':'btn-left','r':'btn-right'};
    const el = document.getElementById(map[action]);
    if (!el) return;
    if (on) el.classList.add('active');
    else el.classList.remove('active');
    // update active list
    // fetch status to get authoritative active list
    fetch('/status').then(r=>r.json()).then(js=>{ setActiveList(js.active_actions || []); setEStop(js.e_stop); }).catch(()=>{});
}

// poll server status periodically
setInterval(()=>{
    fetch('/status').then(r=>r.json()).then(js=>{ setConnState(true); setActiveList(js.active_actions||[]); setEStop(js.e_stop); }).catch(()=>{ setConnState(false); });
}, 1000);

// initial status probe
fetch('/status').then(r=>r.json()).then(js=>{ setConnState(true); setActiveList(js.active_actions||[]); setEStop(js.e_stop); setModeUI(js.mode||'rc');
    // initialize smoothing toggle
    const sm = js.smoothing || false;
    const toggle = document.getElementById('smoothing-toggle');
    if (toggle) toggle.checked = sm;
}).catch(()=>{ setConnState(false); });

// smoothing toggle handler
document.getElementById('smoothing-toggle').addEventListener('change', (ev)=>{
    const v = ev.target.checked;
    fetch('/settings', {method:'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({smoothing: v})})
        .then(r=>r.json()).then(js=>{ /* noop */ }).catch(()=>{ alert('Failed to update settings'); });
});

document.getElementById('t-rcspeed').addEventListener('input', (ev)=>{
    document.getElementById('t-rcspeed-val').textContent = ev.target.value;
});

document.getElementById('t-apply').addEventListener('click', ()=>{
    const payload = {
        det_gamma: parseFloat(document.getElementById('t-gamma').value),
        det_contour_min_area: parseInt(document.getElementById('t-area').value, 10),
        dec_obstacle_stop_ymin: parseFloat(document.getElementById('t-ymin').value),
        det_rock_score_threshold: parseFloat(document.getElementById('t-rockthr').value),
        rc_speed: parseFloat(document.getElementById('t-rcspeed').value)
    };
    fetch('/settings', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)})
        .then(r=>r.json()).then(js=>{ console.log('settings updated', js); })
        .catch(()=>{ alert('Failed to apply tuning'); });
});

// Gamepad support
let gpIndex = null;
let gpPollTimer = null;
const GP_POLL_MS = 100;
const DEADZONE = 0.15;

function setGamepadStatus(connected, name) {
    const el = document.getElementById('gp-status');
    const dot = document.getElementById('gp-dot');
    if (!el) return;
    if (connected) {
        el.textContent = name ? `Connected: ${name}` : 'Connected';
        if (dot) { dot.classList.add('ok'); dot.classList.remove('bad'); }
    } else {
        el.textContent = 'Not connected';
        if (dot) { dot.classList.remove('ok'); dot.classList.remove('bad'); }
    }
}

function pollGamepad() {
    const gps = navigator.getGamepads ? navigator.getGamepads() : [];
    if (!gps) return;
    const g = gpIndex !== null ? gps[gpIndex] : null;
    if (!g) return;
    // map left stick (axes[0]=lx, axes[1]=ly) and right stick horizontal axes[2]
    const lx = g.axes[0] || 0;
    const ly = g.axes[1] || 0;
    const rx = g.axes[2] || 0;
    // apply deadzone
    const applyDZ = (v) => Math.abs(v) < DEADZONE ? 0 : v;
    const plx = applyDZ(lx), ply = applyDZ(ly), prx = applyDZ(rx);
    // send joystick only if in RC mode
    if (currentMode === 'rc') {
        fetch('/joystick', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({lx: plx, ly: ply, rx: prx})})
            .catch(()=>{});
    }
}

window.addEventListener('gamepadconnected', (e)=>{
    gpIndex = e.gamepad.index;
    console.log('Gamepad connected', e.gamepad.id);
    setConnState(true);
    setGamepadStatus(true, e.gamepad.id);
    if (gpPollTimer) clearInterval(gpPollTimer);
    gpPollTimer = setInterval(pollGamepad, GP_POLL_MS);
});

window.addEventListener('gamepaddisconnected', (e)=>{
    if (gpIndex === e.gamepad.index) gpIndex = null;
    if (gpPollTimer) { clearInterval(gpPollTimer); gpPollTimer = null; }
    setGamepadStatus(false);
});

// initial probe (in case the page loads after the controller is already connected)
try {
    const gps = navigator.getGamepads ? navigator.getGamepads() : [];
    const first = gps && gps.length ? gps.find(g => g) : null;
    if (first) {
        gpIndex = first.index;
        setGamepadStatus(true, first.id);
        gpPollTimer = setInterval(pollGamepad, GP_POLL_MS);
    } else {
        setGamepadStatus(false);
    }
} catch (e) {
    setGamepadStatus(false);
}

</script>

</body>
</html>
